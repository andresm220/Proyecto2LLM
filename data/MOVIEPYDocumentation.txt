moviepy
Imports everything that you need from the MoviePy submodules so that every thing can be directly imported with from moviepy import *.

Modules

moviepy.Clip

Implements the central object of MoviePy, the Clip, and all the methods that are common to the two subclasses of Clip, VideoClip and AudioClip.

moviepy.Effect()

Base abstract class for all effects in MoviePy.

moviepy.audio

Everything about audio manipulation.

moviepy.config

Third party programs configuration for MoviePy.

moviepy.decorators

Decorators used by moviepy.

moviepy.tools

Misc.

moviepy.video

Everything about video manipulation.


moviepy.Clip.Clip
class moviepy.Clip.Clip[source]
Base class of all clips (VideoClips and AudioClips).

start
When the clip is included in a composition, time of the composition at which the clip starts playing (in seconds).

Type
:
float

end
When the clip is included in a composition, time of the composition at which the clip stops playing (in seconds).

Type
:
float

duration
Duration of the clip (in seconds). Some clips are infinite, in this case their duration will be None.

Type
:
float

close()[source]
Release any resources that are in use.

copy()[source]
Allows the usage of .copy() in clips as chained methods invocation.

get_frame(t)[source]
Gets a numpy array representing the RGB picture of the clip, or (mono or stereo) value for a sound clip, at time t.

Parameters
:
t (float or tuple or str) – Moment of the clip whose frame will be returned.

is_playing(t)[source]
If t is a time, returns true if t is between the start and the end of the clip. t can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’. If t is a numpy array, returns False if none of the t is in the clip, else returns a vector [b_1, b_2, b_3…] where b_i is true if tti is in the clip.

iter_frames(fps=None, with_times=False, logger=None, dtype=None)[source]
Iterates over all the frames of the clip.

Returns each frame of the clip as a HxWxN Numpy array, where N=1 for mask clips and N=3 for RGB clips.

This function is not really meant for video editing. It provides an easy way to do frame-by-frame treatment of a video, for fields like science, computer vision…

Parameters
:
fps (int, optional) – Frames per second for clip iteration. Is optional if the clip already has a fps attribute.

with_times (bool, optional) – Ff True yield tuples of (t, frame) where t is the current time for the frame, otherwise only a frame object.

logger (str, optional) – Either "bar" for progress bar or None or any Proglog logger.

dtype (type, optional) – Type to cast Numpy array frames. Use dtype="uint8" when using the pictures to write video, images..

Examples

# prints the maximum of red that is contained
# on the first line of each frame of the clip.
from moviepy import VideoFileClip
myclip = VideoFileClip('myvideo.mp4')
print([frame[0,:,0].max()
      for frame in myclip.iter_frames()])
subclipped(start_time=0, end_time=None)[source]
Returns a clip playing the content of the current clip between times start_time and end_time, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’.

The mask and audio of the resulting subclip will be subclips of mask and audio the original clip, if they exist.

It’s equivalent to slice the clip as a sequence, like clip[t_start:t_end].

Parameters
:
start_time (float or tuple or str, optional) – Moment that will be chosen as the beginning of the produced clip. If is negative, it is reset to clip.duration + start_time.

end_time (float or tuple or str, optional) –

Moment that will be chosen as the end of the produced clip. If not provided, it is assumed to be the duration of the clip (potentially infinite). If is negative, it is reset to clip.duration + end_time. For instance:

# cut the last two seconds of the clip:
new_clip = clip.subclipped(0, -2)
If end_time is provided or if the clip has a duration attribute, the duration of the returned clip is set automatically.

time_transform(time_func, apply_to=None, keep_duration=False)[source]
Returns a Clip instance playing the content of the current clip but with a modified timeline, time t being replaced by the return of time_func(t).

Parameters
:
time_func (function) – A function t -> new_t.

apply_to ({"mask", "audio", ["mask", "audio"]}, optional) – Can be either ‘mask’, or ‘audio’, or [‘mask’,’audio’]. Specifies if the filter transform should also be applied to the audio or the mask of the clip, if any.

keep_duration (bool, optional) – False (default) if the transformation modifies the duration of the clip.

Examples

# plays the clip (and its mask and sound) twice faster
new_clip = clip.time_transform(lambda t: 2*t, apply_to=['mask', 'audio'])

# plays the clip starting at t=3, and backwards:
new_clip = clip.time_transform(lambda t: 3-t)
transform(func, apply_to=None, keep_duration=True)[source]
General processing of a clip.

Returns a new Clip whose frames are a transformation (through function func) of the frames of the current clip.

Parameters
:
func (function) – A function with signature (gf,t -> frame) where gf will represent the current clip’s get_frame method, i.e. gf is a function (t->image). Parameter t is a time in seconds, frame is a picture (=Numpy array) which will be returned by the transformed clip (see examples below).

apply_to ({"mask", "audio", ["mask", "audio"]}, optional) – Can be either 'mask', or 'audio', or ['mask','audio']. Specifies if the filter should also be applied to the audio or the mask of the clip, if any.

keep_duration (bool, optional) – Set to True if the transformation does not change the duration of the clip.

Examples

In the following new_clip a 100 pixels-high clip whose video content scrolls from the top to the bottom of the frames of clip at 50 pixels per second.

filter = lambda get_frame,t : get_frame(t)[int(t):int(t)+50, :]
new_clip = clip.transform(filter, apply_to='mask')
with_duration(duration, change_end=True)[source]
Returns a copy of the clip, with the duration attribute set to t, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’. Also sets the duration of the mask and audio, if any, of the returned clip.

If change_end is False, the start attribute of the clip will be modified in function of the duration and the preset end of the clip.

Parameters
:
duration (float) – New duration attribute value for the clip.

change_end (bool, optional) – If True, the end attribute value of the clip will be adjusted accordingly to the new duration using clip.start + duration.

with_effects(effects: List[Effect])[source]
Return a copy of the current clip with the effects applied

new_clip = clip.with_effects([vfx.Resize(0.2, method="bilinear")])
You can also pass multiple effect as a list

clip.with_effects([afx.VolumeX(0.5), vfx.Resize(0.3), vfx.Mirrorx()])
with_end(t)[source]
Returns a copy of the clip, with the end attribute set to t, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’. Also sets the duration of the mask and audio, if any, of the returned clip.

note::
The start and end attribute of a clip define when a clip will start playing when used in a composite video clip, not the start time of the clip itself.

i.e: with_start(10) mean the clip will still start at his first frame, but if used in a composite video clip it will only start to show at 10 seconds.

Parameters
:
t (float or tuple or str) – New end attribute value for the clip.

with_fps(fps, change_duration=False)[source]
Returns a copy of the clip with a new default fps for functions like write_videofile, iterframe, etc.

Parameters
:
fps (int) – New fps attribute value for the clip.

change_duration (bool, optional) – If change_duration=True, then the video speed will change to match the new fps (conserving all frames 1:1). For example, if the fps is halved in this mode, the duration will be doubled.

with_is_mask(is_mask)[source]
Says whether the clip is a mask or not.

Parameters
:
is_mask (bool) – New is_mask attribute value for the clip.

with_memoize(memoize)[source]
Sets whether the clip should keep the last frame read in memory.

Parameters
:
memoize (bool) – Indicates if the clip should keep the last frame read in memory.

with_section_cut_out(start_time, end_time)[source]
Returns a clip playing the content of the current clip but skips the extract between start_time and end_time, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’.

If the original clip has a duration attribute set, the duration of the returned clip is automatically computed as `` duration - (end_time - start_time)``.

The resulting clip’s audio and mask will also be cutout if they exist.

Parameters
:
start_time (float or tuple or str) – Moment from which frames will be ignored in the resulting output.

end_time (float or tuple or str) – Moment until which frames will be ignored in the resulting output.

with_speed_scaled(factor: float = None, final_duration: float = None)[source]
Returns a clip playing the current clip but at a speed multiplied by factor. For info on the parameters, please see vfx.MultiplySpeed.

with_start(t, change_end=True)[source]
Returns a copy of the clip, with the start attribute set to t, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’.

These changes are also applied to the audio and mask clips of the current clip, if they exist.

note::
The start and end attribute of a clip define when a clip will start playing when used in a composite video clip, not the start time of the clip itself.

i.e: with_start(10) mean the clip will still start at his first frame, but if used in a composite video clip it will only start to show at 10 seconds.

Parameters
:
t (float or tuple or str) – New start attribute value for the clip.

change_end (bool optional) – Indicates if the end attribute value must be changed accordingly, if possible. If change_end=True and the clip has a duration attribute, the end attribute of the clip will be updated to start + duration. If change_end=False and the clip has a end attribute, the duration attribute of the clip will be updated to end - start.

with_updated_frame_function(frame_function)[source]
Sets a frame_function attribute for the clip. Useful for setting arbitrary/complicated videoclips.

Parameters
:
frame_function (function) – New frame creator function for the clip.

with_volume_scaled(factor: float, start_time=None, end_time=None)[source]
Returns a new clip with audio volume multiplied by the value factor. For info on the parameters, please see afx.MultiplyVolume


moviepy.Effect
Defines the base class for all effects in MoviePy.

class moviepy.Effect.Effect[source]
Base abstract class for all effects in MoviePy. Any new effect have to extend this base class.

abstract apply(clip: Clip) → Clip[source]
Apply the current effect on a clip

Parameters
:
clip – The target clip to apply the effect on. (Internally, MoviePy will always pass a copy of the original clip)

copy()[source]
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio
Everything about audio manipulation.

Modules

moviepy.audio.AudioClip

Implements AudioClip (base class for audio clips) and its main subclasses:

moviepy.audio.fx

All the audio effects that can be applied to AudioClip and VideoClip.

moviepy.audio.io

Class and methods to read, write, preview audiofiles.

moviepy.audio.tools

Tools to better processing and edition of audio.

moviepy.audio.AudioClip
Implements AudioClip (base class for audio clips) and its main subclasses:

Audio clips: AudioClip, AudioFileClip, AudioArrayClip

Composition: CompositeAudioClip

Classes

AudioArrayClip(array, fps)

An audio clip made from a sound array.

AudioClip([frame_function, duration, fps])

Base class for audio clips.

CompositeAudioClip(clips)

Clip made by composing several AudioClips.

Functions

concatenate_audioclips(clips)

Concatenates one AudioClip after another, in the order that are passed to clips parameter.

moviepy.audio.AudioClip.AudioArrayClip
class moviepy.audio.AudioClip.AudioArrayClip(array, fps)[source]
An audio clip made from a sound array.

Parameters
:
array – A Numpy array representing the sound, of size Nx1 for mono, Nx2 for stereo.

fps – Frames per second : speed at which the sound is supposed to be played.

moviepy.audio.AudioClip.AudioClip
class moviepy.audio.AudioClip.AudioClip(frame_function=None, duration=None, fps=None)[source]
Base class for audio clips.

See AudioFileClip and CompositeAudioClip for usable classes.

An AudioClip is a Clip with a frame_function attribute of the form `` t -> [ f_t ]`` for mono sound and t-> [ f1_t, f2_t ] for stereo sound (the arrays are Numpy arrays). The f_t are floats between -1 and 1. These bounds can be trespassed without problems (the program will put the sound back into the bounds at conversion time, without much impact).

Parameters
:
frame_function – A function t-> frame at time t. The frame does not mean much for a sound, it is just a float. What ‘makes’ the sound are the variations of that float in the time.

duration – Duration of the clip (in seconds). Some clips are infinite, in this case their duration will be None.

nchannels – Number of channels (one or two for mono or stereo).

Examples

# Plays the note A in mono (a sine wave of frequency 440 Hz)
import numpy as np
frame_function = lambda t: np.sin(440 * 2 * np.pi * t)
clip = AudioClip(frame_function, duration=5, fps=44100)
clip.preview()

# Plays the note A in stereo (two sine waves of frequencies 440 and 880 Hz)
frame_function = lambda t: np.array([
    np.sin(440 * 2 * np.pi * t),
    np.sin(880 * 2 * np.pi * t)
]).T.copy(order="C")
clip = AudioClip(frame_function, duration=3, fps=44100)
clip.preview()
audiopreview(fps=None, buffersize=2000, nbytes=2, audio_flag=None, video_flag=None)[source]
Preview an AudioClip using ffplay

Parameters
:
fps – Frame rate of the sound. 44100 gives top quality, but may cause problems if your computer is not fast enough and your clip is complicated. If the sound jumps during the preview, lower it (11025 is still fine, 5000 is tolerable).

buffersize – The sound is not generated all at once, but rather made by bunches of frames (chunks). buffersize is the size of such a chunk. Try varying it if you meet audio problems (but you shouldn’t have to).

nbytes – Number of bytes to encode the sound: 1 for 8bit sound, 2 for 16bit, 4 for 32bit sound. 2 bytes is fine.

audio_flag – Instances of class threading events that are used to synchronize video and audio during VideoClip.preview().

video_flag – Instances of class threading events that are used to synchronize video and audio during VideoClip.preview().

display_in_notebook(filetype=None, maxduration=60, t=None, fps=None, rd_kwargs=None, center=True, **html_kwargs)
Displays clip content in an Jupyter Notebook.

Remarks: If your browser doesn’t support HTML5, this should warn you. If nothing is displayed, maybe your file or filename is wrong. Important: The media will be physically embedded in the notebook.

Parameters
:
clip (moviepy.Clip.Clip) – Either the name of a file, or a clip to preview. The clip will actually be written to a file and embedded as if a filename was provided.

filetype (str, optional) – One of "video", "image" or "audio". If None is given, it is determined based on the extension of filename, but this can bug.

maxduration (float, optional) – An error will be raised if the clip’s duration is more than the indicated value (in seconds), to avoid spoiling the browser’s cache and the RAM.

t (float, optional) – If not None, only the frame at time t will be displayed in the notebook, instead of a video of the clip.

fps (int, optional) – Enables to specify an fps, as required for clips whose fps is unknown.

rd_kwargs (dict, optional) – Keyword arguments for the rendering, like dict(fps=15, bitrate="50k"). Allow you to give some options to the render process. You can, for example, disable the logger bar passing dict(logger=None).

center (bool, optional) – If true (default), the content will be wrapped in a <div align=middle> HTML container, so the content will be displayed at the center.

kwargs – Allow you to give some options, like width=260, etc. When editing looping gifs, a good choice is loop=1, autoplay=1.

Examples

from moviepy import *
# later ...
clip.display_in_notebook(width=360)
clip.audio.display_in_notebook()

clip.write_gif("test.gif")
display_in_notebook('test.gif')

clip.save_frame("first_frame.jpeg")
display_in_notebook("first_frame.jpeg")
iter_chunks(chunksize=None, chunk_duration=None, fps=None, quantize=False, nbytes=2, logger=None)[source]
Iterator that returns the whole sound array of the clip by chunks

max_volume(stereo=False, chunksize=50000, logger=None)[source]
Returns the maximum volume level of the clip.

to_soundarray(tt=None, fps=None, quantize=False, nbytes=2, buffersize=50000)[source]
Transforms the sound into an array that can be played by pygame or written in a wav file. See AudioClip.preview.

Parameters
:
fps – Frame rate of the sound for the conversion. 44100 for top quality.

nbytes – Number of bytes to encode the sound: 1 for 8bit sound, 2 for 16bit, 4 for 32bit sound.

write_audiofile(filename, fps=None, nbytes=2, buffersize=2000, codec=None, bitrate=None, ffmpeg_params=None, write_logfile=False, logger='bar')[source]
Writes an audio file from the AudioClip.

Parameters
:
filename – Name of the output file, as a string or a path-like object.

fps – Frames per second. If not set, it will try default to self.fps if already set, otherwise it will default to 44100.

nbytes – Sample width (set to 2 for 16-bit sound, 4 for 32-bit sound)

buffersize – The sound is not generated all at once, but rather made by bunches of frames (chunks). buffersize is the size of such a chunk. Try varying it if you meet audio problems (but you shouldn’t have to). Default to 2000

codec – Which audio codec should be used. If None provided, the codec is determined based on the extension of the filename. Choose ‘pcm_s16le’ for 16-bit wav and ‘pcm_s32le’ for 32-bit wav.

bitrate – Audio bitrate, given as a string like ‘50k’, ‘500k’, ‘3000k’. Will determine the size and quality of the output file. Note that it mainly an indicative goal, the bitrate won’t necessarily be the this in the output file.

ffmpeg_params – Any additional parameters you would like to pass, as a list of terms, like [‘-option1’, ‘value1’, ‘-option2’, ‘value2’]

write_logfile – If true, produces a detailed logfile named filename + ‘.log’ when writing the file

logger – Either "bar" for progress bar or None or any Proglog logger.

moviepy.audio.AudioClip.CompositeAudioClip
class moviepy.audio.AudioClip.CompositeAudioClip(clips)[source]
Clip made by composing several AudioClips.

An audio clip made by putting together several audio clips.

Parameters
:
clips – List of audio clips, which may start playing at different times or together, depends on their start attributes. If all have their duration attribute set, the duration of the composite clip is computed automatically.

property ends
Returns ending times for all clips in the composition.

frame_function(t)[source]
Renders a frame for the composition for the time t.

property starts
Returns starting times for all clips in the composition.

moviepy.audio.AudioClip.concatenate_audioclips
moviepy.audio.AudioClip.concatenate_audioclips(clips)[source]
Concatenates one AudioClip after another, in the order that are passed to clips parameter.

Parameters
:
clips – List of audio clips, which will be played one after other.

moviepy.audio.fx
All the audio effects that can be applied to AudioClip and VideoClip.

Modules

moviepy.audio.fx.AudioDelay([offset, ...])

Repeats audio certain number of times at constant intervals multiplying their volume levels using a linear space in the range 1 to decay argument value.

moviepy.audio.fx.AudioFadeIn(duration)

Return an audio (or video) clip that is first mute, then the sound arrives progressively over duration seconds.

moviepy.audio.fx.AudioFadeOut(duration)

Return a sound clip where the sound fades out progressively over duration seconds at the end of the clip.

moviepy.audio.fx.AudioLoop([n_loops, duration])

Loops over an audio clip.

moviepy.audio.fx.AudioNormalize()

Return a clip whose volume is normalized to 0db.

moviepy.audio.fx.MultiplyStereoVolume([...])

For a stereo audioclip, this function enables to change the volume of the left and right channel separately (with the factors left and right).

moviepy.audio.fx.MultiplyVolume(factor[, ...])

Returns a clip with audio volume multiplied by the value factor.

moviepy.audio.fx.AudioDelay
class moviepy.audio.fx.AudioDelay.AudioDelay(offset: float = 0.2, n_repeats: int = 8, decay: float = 1)[source]
Repeats audio certain number of times at constant intervals multiplying their volume levels using a linear space in the range 1 to decay argument value.

Parameters
:
offset (float, optional) – Gap between repetitions start times, in seconds.

n_repeats (int, optional) – Number of repetitions (without including the clip itself).

decay (float, optional) – Multiplication factor for the volume level of the last repetition. Each repetition will have a value in the linear function between 1 and this value, increasing or decreasing constantly. Keep in mind that the last repetition will be muted if this is 0, and if is greater than 1, the volume will increase for each repetition.

Examples

from moviepy import *
videoclip = AudioFileClip('myaudio.wav').with_effects([
    afx.AudioDelay(offset=.2, n_repeats=10, decayment=.2)
])

# stereo A note
frame_function = lambda t: np.array(
    [np.sin(440 * 2 * np.pi * t), np.sin(880 * 2 * np.pi * t)]
).T
clip = AudioClip(frame_function=frame_function, duration=0.1, fps=44100)
clip = clip.with_effects([afx.AudioDelay(offset=.2, n_repeats=11, decay=0)])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.AudioFadeIn
class moviepy.audio.fx.AudioFadeIn.AudioFadeIn(duration: float)[source]
Return an audio (or video) clip that is first mute, then the sound arrives progressively over duration seconds.

Parameters
:
duration (float) – How long does it take for the sound to return to its normal level.

Examples

clip = VideoFileClip("media/chaplin.mp4")
clip.with_effects([afx.AudioFadeIn("00:00:06")])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.AudioFadeOut
class moviepy.audio.fx.AudioFadeOut.AudioFadeOut(duration: float)[source]
Return a sound clip where the sound fades out progressively over duration seconds at the end of the clip.

Parameters
:
duration (float) – How long does it take for the sound to reach the zero level at the end of the clip.

Examples

clip = VideoFileClip("media/chaplin.mp4")
clip.with_effects([afx.AudioFadeOut("00:00:06")])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.AudioLoop
class moviepy.audio.fx.AudioLoop.AudioLoop(n_loops: int = None, duration: float = None)[source]
Loops over an audio clip.

Returns an audio clip that plays the given clip either n_loops times, or during duration seconds.

Examples

from moviepy import *
videoclip = VideoFileClip('myvideo.mp4')
music = AudioFileClip('music.ogg')
audio = music.with_effects([afx.AudioLoop(duration=videoclip.duration)])
videoclip.with_audio(audio)
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.AudioNormalize
class moviepy.audio.fx.AudioNormalize.AudioNormalize[source]
Return a clip whose volume is normalized to 0db.

Return an audio (or video) clip whose audio volume is normalized so that the maximum volume is at 0db, the maximum achievable volume.

Examples

from moviepy import *
videoclip = VideoFileClip('myvideo.mp4').with_effects([afx.AudioNormalize()])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.MultiplyStereoVolume
class moviepy.audio.fx.MultiplyStereoVolume.MultiplyStereoVolume(left: float = 1, right: float = 1)[source]
For a stereo audioclip, this function enables to change the volume of the left and right channel separately (with the factors left and right). Makes a stereo audio clip in which the volume of left and right is controllable.

Examples

from moviepy import AudioFileClip
music = AudioFileClip('music.ogg')
# mutes left channel
audio_r = music.with_effects([afx.MultiplyStereoVolume(left=0, right=1)])
# halves audio volume
audio_h = music.with_effects([afx.MultiplyStereoVolume(left=0.5, right=0.5)])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.fx.MultiplyVolume
class moviepy.audio.fx.MultiplyVolume.MultiplyVolume(factor: float, start_time: float = None, end_time: float = None)[source]
Returns a clip with audio volume multiplied by the value factor. Can be applied to both audio and video clips.

Parameters
:
factor (float) – Volume multiplication factor.

start_time (float, optional) – Time from the beginning of the clip until the volume transformation begins to take effect, in seconds. By default at the beginning.

end_time (float, optional) – Time from the beginning of the clip until the volume transformation ends to take effect, in seconds. By default at the end.

Examples

from moviepy import AudioFileClip

music = AudioFileClip("music.ogg")
# doubles audio volume
doubled_audio_clip = music.with_effects([afx.MultiplyVolume(2)])
# halves audio volume
half_audio_clip = music.with_effects([afx.MultiplyVolume(0.5)])
# silences clip during one second at third
effect = afx.MultiplyVolume(0, start_time=2, end_time=3)
silenced_clip = clip.with_effects([effect])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.audio.io
Class and methods to read, write, preview audiofiles.

Modules

moviepy.audio.io.AudioFileClip

Implements AudioFileClip, a class for audio clips creation using audio files.

moviepy.audio.io.ffmpeg_audiowriter

MoviePy audio writing with ffmpeg.

moviepy.audio.io.ffplay_audiopreviewer

MoviePy audio writing with ffmpeg.

moviepy.audio.io.readers

MoviePy audio reading with ffmpeg.

moviepy.audio.io.AudioFileClip
Implements AudioFileClip, a class for audio clips creation using audio files.

Classes

AudioFileClip(filename[, decode_file, ...])

An audio clip read from a sound file, or an array.

moviepy.audio.io.ffmpeg_audiowriter
MoviePy audio writing with ffmpeg.

Classes

FFMPEG_AudioWriter(filename, fps_input[, ...])

A class to write an AudioClip into an audio file.

Functions

ffmpeg_audiowrite(clip, filename, fps, ...)

A function that wraps the FFMPEG_AudioWriter to write an AudioClip to a file.

previous

moviepy.audio.io.AudioFileClip.AudioFileClip

next

moviepy.audio.io.ffmpeg_audiowriter.FFMPEG_AudioWriter

 Edit on GitHub

 moviepy.audio.io.ffplay_audiopreviewer
MoviePy audio writing with ffmpeg.

Classes

FFPLAY_AudioPreviewer(fps_input[, nbytes, ...])

A class to preview an AudioClip.

Functions

ffplay_audiopreview(clip[, fps, buffersize, ...])

A function that wraps the FFPLAY_AudioPreviewer to preview an AudioClip



moviepy.audio.io.readers
MoviePy audio reading with ffmpeg.

Classes

FFMPEG_AudioReader(filename, buffersize[, ...])

A class to read the audio in either video files or audio files using ffmpeg.


moviepy.audio.tools
Tools to better processing and edition of audio.

Modules

moviepy.audio.tools.cuts

Cutting utilities working with audio.

moviepy.audio.tools.cuts
Cutting utilities working with audio.

Functions

find_audio_period(clip[, min_time, ...])

Finds the period, in seconds of an audioclip.


moviepy.config
Third party programs configuration for MoviePy.

Functions

check()

Check if moviepy has found the binaries for FFmpeg.

try_cmd(cmd)

Verify if the OS support command invocation as expected by moviepy

moviepy.config.check
moviepy.config.check()[source]
Check if moviepy has found the binaries for FFmpeg.

moviepy.config.try_cmd
moviepy.config.try_cmd(cmd)[source]
Verify if the OS support command invocation as expected by moviepy

moviepy.decorators
Decorators used by moviepy.

Functions

add_mask_if_none(func, clip, *args, **kwargs)

Add a mask to the clip if there is none.

apply_to_audio(func, clip, *args, **kwargs)

Applies the function func to the audio of the clip created with func.

apply_to_mask(func, clip, *args, **kwargs)

Applies the same function func to the mask of the clip created with func.

audio_video_effect(func, effect, clip, ...)

Use an audio function on a video/audio clip.

convert_masks_to_RGB(func, clip, *args, **kwargs)

If the clip is a mask, convert it to RGB before running the function.

convert_parameter_to_seconds(varnames)

Converts the specified variables to seconds.

convert_path_to_string(varnames)

Converts the specified variables to a path string.

outplace(func, clip, *args, **kwargs)

Applies func(clip.copy(), *args, **kwargs) and returns clip.copy().

preprocess_args(preprocess_func, varnames)

Applies preprocess_func to variables in varnames before launching the function.

requires_duration(func, clip, *args, **kwargs)

Raises an error if the clip has no duration.

requires_fps(func, clip, *args, **kwargs)

Raises an error if the clip has no fps.

use_clip_fps_by_default(func)

Will use clip.fps if no fps=... is provided in kwargs.

moviepy.decorators.add_mask_if_none
moviepy.decorators.add_mask_if_none(func, clip, *args, **kwargs)[source]
Add a mask to the clip if there is none.

moviepy.decorators.apply_to_audio
moviepy.decorators.apply_to_audio(func, clip, *args, **kwargs)[source]
Applies the function func to the audio of the clip created with func.

moviepy.decorators.apply_to_mask
moviepy.decorators.apply_to_mask(func, clip, *args, **kwargs)[source]
Applies the same function func to the mask of the clip created with func.

moviepy.decorators.audio_video_effect
moviepy.decorators.audio_video_effect(func, effect, clip, *args, **kwargs)[source]
Use an audio function on a video/audio clip.

This decorator tells that the function func (audioclip -> audioclip) can be also used on a video clip, at which case it returns a videoclip with unmodified video and modified audio.

moviepy.decorators.convert_masks_to_RGB
moviepy.decorators.convert_masks_to_RGB(func, clip, *args, **kwargs)[source]
If the clip is a mask, convert it to RGB before running the function.

moviepy.decorators.convert_parameter_to_seconds
moviepy.decorators.convert_parameter_to_seconds(varnames)[source]
Converts the specified variables to seconds.

moviepy.decorators.convert_path_to_string
moviepy.decorators.convert_path_to_string(varnames)[source]
Converts the specified variables to a path string.

moviepy.decorators.outplace
moviepy.decorators.outplace(func, clip, *args, **kwargs)[source]
Applies func(clip.copy(), *args, **kwargs) and returns clip.copy().

moviepy.decorators.preprocess_args
moviepy.decorators.preprocess_args(preprocess_func, varnames)[source]
Applies preprocess_func to variables in varnames before launching the function.

moviepy.decorators.requires_duration
moviepy.decorators.requires_duration(func, clip, *args, **kwargs)[source]
Raises an error if the clip has no duration.

moviepy.decorators.requires_fps
moviepy.decorators.requires_fps(func, clip, *args, **kwargs)[source]
Raises an error if the clip has no fps.

moviepy.decorators.use_clip_fps_by_default
moviepy.decorators.use_clip_fps_by_default(func)[source]
Will use clip.fps if no fps=... is provided in kwargs.

moviepy.tools
Misc. useful functions that can be used at many places in the program.

Functions

close_all_clips([objects, types])

Closes all clips in a context.

compute_position(clip1_size, clip2_size, pos)

Return the position to put clip 1 on clip 2 based on both clip size and the position of clip 1, as return by clip1.pos() method

convert_to_seconds(time)

Will convert any time into seconds.

cross_platform_popen_params(popen_params)

Wrap with this function a dictionary of subprocess.Popen kwargs and will be ready to work without unexpected behaviours in any platform.

deprecated_version_of(func, old_name)

Indicates that a function is deprecated and has a new name.

ffmpeg_escape_filename(filename)

Escape a filename that we want to pass to the ffmpeg command line

find_extension(codec)

Returns the correspondent file extension for a codec.

no_display_available()

Return True if we determine the host system has no graphical environment.

subprocess_call(cmd[, logger])

Executes the given subprocess command.

moviepy.tools.close_all_clips
moviepy.tools.close_all_clips(objects='globals', types=('audio', 'video', 'image'))[source]
Closes all clips in a context.

Follows different strategies retrieving the namespace from which the clips to close will be retrieved depending on the objects argument, and filtering by type of clips depending on the types argument.

Parameters
:
objects (str or dict, optional) –

If is a string an the value is "globals", will close all the clips contained by the globals() namespace.

If is a dictionary, the values of the dictionary could be clips to close, useful if you want to use locals().

types (Iterable, optional) – Set of types of clips to close, being “audio”, “video” or “image” the supported values.

moviepy.tools.compute_position
moviepy.tools.compute_position(clip1_size: tuple, clip2_size: tuple, pos: any, relative: bool = False) → tuple[int, int][source]
Return the position to put clip 1 on clip 2 based on both clip size and the position of clip 1, as return by clip1.pos() method

Parameters
:
clip1_size (tuple) – The width and height of clip1 (e.g., (width, height)).

clip2_size (tuple) – The width and height of clip2 (e.g., (width, height)).

pos (Any) – The position of clip1 as returned by the clip1.pos() method.

relative (bool) – Is the position relative (% of clip size), default False.

Returns
:
A tuple (x, y) representing the top-left corner of clip1 relative to clip2.

Return type
:
tuple[int, int]

Notes

For more information on pos, see the documentation for VideoClip.with_position.

moviepy.tools.convert_to_seconds
moviepy.tools.convert_to_seconds(time)[source]
Will convert any time into seconds.

If the type of time is not valid, it’s returned as is.

Here are the accepted formats:

convert_to_seconds(15.4)   # seconds
15.4
convert_to_seconds((1, 21.5))   # (min,sec)
81.5
convert_to_seconds((1, 1, 2))   # (hr, min, sec)
3662
convert_to_seconds('01:01:33.045')
3693.045
convert_to_seconds('01:01:33,5')    # coma works too
3693.5
convert_to_seconds('1:33,5')    # only minutes and secs
99.5
convert_to_seconds('33.5')      # only secs
33.5

moviepy.tools.cross_platform_popen_params
moviepy.tools.cross_platform_popen_params(popen_params)[source]
Wrap with this function a dictionary of subprocess.Popen kwargs and will be ready to work without unexpected behaviours in any platform. Currently, the implementation will add to them:

creationflags=0x08000000: no extra unwanted window opens on Windows when the child process is created. Only added on Windows.

moviepy.tools.deprecated_version_of
moviepy.tools.deprecated_version_of(func, old_name)[source]
Indicates that a function is deprecated and has a new name.

func is the new function and old_name is the name of the deprecated function.

Returns
:
A function that does the same thing as func, but with a docstring and a printed message on call which say that the function is deprecated and that you should use func instead.

Return type
:
deprecated_func

Examples

# The badly named method 'to_file' is replaced by 'write_file'
class Clip:
    def write_file(self, some args):
        # blablabla
Clip.to_file = deprecated_version_of(Clip.write_file, 'to_file')

moviepy.tools.ffmpeg_escape_filename
moviepy.tools.ffmpeg_escape_filename(filename)[source]
Escape a filename that we want to pass to the ffmpeg command line

That will ensure the filename doesn’t start with a ‘-’ (which would raise an error)

moviepy.tools.find_extension
moviepy.tools.find_extension(codec)[source]
Returns the correspondent file extension for a codec.

Parameters
:
codec (str) – Video or audio codec name.

moviepy.tools.no_display_available
moviepy.tools.no_display_available() → bool[source]
Return True if we determine the host system has no graphical environment. This is usefull to remove tests requiring display, like preview

..info::
Currently this only works for Linux/BSD systems with X11 or wayland. It probably works for SunOS, AIX and CYGWIN

moviepy.tools.subprocess_call
moviepy.tools.subprocess_call(cmd, logger='bar')[source]
Executes the given subprocess command.

Set logger to None or a custom Proglog logger to avoid printings.

moviepy.video
Everything about video manipulation.

Modules

moviepy.video.VideoClip

Implements VideoClip (base class for video clips) and its main subclasses:

moviepy.video.compositing

All for compositing video clips.

moviepy.video.fx

All the visual effects that can be applied to VideoClip.

moviepy.video.io

Classes and methods for reading, writing and previewing video files.

moviepy.video.tools


moviepy.video.VideoClip
Implements VideoClip (base class for video clips) and its main subclasses:

Animated clips: VideoFileClip, ImageSequenceClip, BitmapClip

Static image clips: ImageClip, ColorClip, TextClip,

Classes

BitmapClip(bitmap_frames, *[, fps, ...])

Clip made of color bitmaps.

ColorClip(size[, color, is_mask, duration])

An ImageClip showing just one color.

DataVideoClip(data, data_to_frame, fps[, ...])

Class of video clips whose successive frames are functions of successive datasets

ImageClip(img[, is_mask, transparent, ...])

Class for non-moving VideoClips.

TextClip([font, text, filename, font_size, ...])

Class for autogenerated text clips.

UpdatedVideoClip(world[, is_mask, duration])

Class of clips whose frame_function requires some objects to be updated.

VideoClip([frame_function, is_mask, ...])

Base class for video clips.

moviepy.video.VideoClip.BitmapClip
class moviepy.video.VideoClip.BitmapClip(bitmap_frames, *, fps=None, duration=None, color_dict=None, is_mask=False)[source]
Clip made of color bitmaps. Mainly designed for testing purposes.

to_bitmap(color_dict=None)[source]
Returns a valid bitmap list that represents each frame of the clip. If color_dict is not specified, then it will use the same color_dict that was used to create the clip.

moviepy.video.VideoClip.ColorClip
class moviepy.video.VideoClip.ColorClip(size, color=None, is_mask=False, duration=None)[source]
An ImageClip showing just one color.

Parameters
:
size – Size tuple (width, height) in pixels of the clip.

color – If argument is_mask is False, color indicates the color in RGB of the clip (default is black). If is_mask` is True, color must be a float between 0 and 1 (default is 1)

is_mask – Set to true if the clip will be used as a mask.

moviepy.video.VideoClip.DataVideoClip
class moviepy.video.VideoClip.DataVideoClip(data, data_to_frame, fps, is_mask=False, has_constant_size=True)[source]
Class of video clips whose successive frames are functions of successive datasets

Parameters
:
data – A list of datasets, each dataset being used for one frame of the clip

data_to_frame – A function d -> video frame, where d is one element of the list data

fps – Number of frames per second in the animation

moviepy.video.VideoClip.ImageClip
class moviepy.video.VideoClip.ImageClip(img, is_mask=False, transparent=True, fromalpha=False, duration=None)[source]
Class for non-moving VideoClips.

A video clip originating from a picture. This clip will simply display the given picture at all times.

Examples

clip = ImageClip("myHouse.jpeg")
clip = ImageClip( someArray ) # a Numpy array represent
Parameters
:
img – Any picture file (png, tiff, jpeg, etc.) as a string or a path-like object, or any array representing an RGB image (for instance a frame from a VideoClip).

is_mask – Set this parameter to True if the clip is a mask.

transparent – Set this parameter to True (default) if you want the alpha layer of the picture (if it exists) to be used as a mask.

img
Array representing the image of the clip.

image_transform(image_func, apply_to=None)[source]
Image-transformation filter.

Does the same as VideoClip.image_transform, but for ImageClip the transformed clip is computed once and for all at the beginning, and not for each ‘frame’.

time_transform(time_func, apply_to=None, keep_duration=False)[source]
Time-transformation filter.

Applies a transformation to the clip’s timeline (see Clip.time_transform).

This method does nothing for ImageClips (but it may affect their masks or their audios). The result is still an ImageClip.

transform(func, apply_to=None, keep_duration=True)[source]
General transformation filter.

Equivalent to VideoClip.transform. The result is no more an ImageClip, it has the class VideoClip (since it may be animated)

moviepy.video.VideoClip.TextClip
class moviepy.video.VideoClip.TextClip(font=None, text=None, filename=None, font_size=None, size=(None, None), margin=(None, None), color='black', bg_color=None, stroke_color=None, stroke_width=0, method='label', text_align='left', horizontal_align='center', vertical_align='center', interline=4, transparent=True, duration=None)[source]
Class for autogenerated text clips.

Creates an ImageClip originating from a script-generated text image.

Parameters
:
font – Path to the font to use. Must be an OpenType font. If set to None (default) will use Pillow default font

text – A string of the text to write. Can be replaced by argument filename.

filename – The name of a file in which there is the text to write, as a string or a path-like object. Can be provided instead of argument text

font_size – Font size in point. Can be auto-set if method=’caption’, or if method=’label’ and size is set.

size – Size of the picture in pixels. Can be auto-set if method=’label’ and font_size is set, but mandatory if method=’caption’. the height can be None for caption if font_size is defined, it will then be auto-determined.

margin – Margin to be added arround the text as a tuple of two (symmetrical) or four (asymmetrical). Either (horizontal, vertical) or (left, top, right, bottom). By default no margin (None, None). This is especially usefull for auto-compute size to give the text some extra room.

color – Color of the text. Default to “black”. Can be a RGB (or RGBA if transparent = True) tuple, a color name, or an hexadecimal notation.

bg_color – Color of the background. Default to None for no background. Can be a RGB (or RGBA if transparent = True) tuple, a color name, or an hexadecimal notation.

stroke_color – Color of the stroke (=contour line) of the text. If None, there will be no stroke.

stroke_width – Width of the stroke, in pixels. Must be an int.

method –

Either :
’label’ (default), the picture will be autosized so as to fit the text either by auto-computing font size if width is provided or auto-computing width and eight if font size is defined

’caption’ the text will be drawn in a picture with fixed size provided with the size argument. The text will be wrapped automagically, either by auto-computing font size if width and height are provided or adding line break when necesarry if font size is defined

text_align – center | left | right. Text align similar to css. Default to left.

horizontal_align – center | left | right. Define horizontal align of text bloc in image. Default to center.

vertical_align – center | top | bottom. Define vertical align of text bloc in image. Default to center.

interline – Interline spacing. Default to 4.

transparent – True (default) if you want to take into account the transparency in the image.

duration – Duration of the clip

note:: (..) –

** About final TextClip size **

The final TextClip size will be of the absolute maximum height possible for the font and the number of line. It specifically mean that the final height might be a bit bigger than the real text height, i.e, absolute bottom pixel of text - absolute top pixel of text. This is because in a font, some letter go above standard top line (e.g letters with accents), and bellow standard baseline (e.g letters such as p, y, g).

This notion is knowned under the name ascent and descent meaning the highest and lowest pixel above and below baseline

If your first line dont have an “accent character” and your last line dont have a “descent character”, you’ll have some “fat” arround

moviepy.video.VideoClip.UpdatedVideoClip
class moviepy.video.VideoClip.UpdatedVideoClip(world, is_mask=False, duration=None)[source]
Class of clips whose frame_function requires some objects to be updated. Particularly practical in science where some algorithm needs to make some steps before a new frame can be generated.

UpdatedVideoClips have the following frame_function:

def frame_function(t):
    while self.world.clip_t < t:
        world.update() # updates, and increases world.clip_t
    return world.to_frame()
Parameters
:
world – An object with the following attributes: - world.clip_t: the clip’s time corresponding to the world’s state. - world.update() : update the world’s state, (including increasing world.clip_t of one time step). - world.to_frame() : renders a frame depending on the world’s state.

is_mask – True if the clip is a WxH mask with values in 0-1

duration – Duration of the clip, in seconds

moviepy.video.VideoClip.VideoClip
class moviepy.video.VideoClip.VideoClip(frame_function=None, is_mask=False, duration=None, has_constant_size=True)[source]
Base class for video clips.

See VideoFileClip, ImageClip etc. for more user-friendly classes.

Parameters
:
is_mask – True if the clip is going to be used as a mask.

duration – Duration of the clip in seconds. If None we got a clip of infinite duration

has_constant_size – Define if clip size is constant or if it may vary with time. Default to True

size
The size of the clip, (width,height), in pixels.

w, h
The width and height of the clip, in pixels.

is_mask
Boolean set to True if the clip is a mask.

frame_function
A function t-> frame at time t where frame is a w*h*3 RGB array.

mask(default None)
VideoClip mask attached to this clip. If mask is
None
,
The video clip is fully opaque.

audio(default None)
An AudioClip instance containing the audio of the video clip.

pos
A function t->(x,y) where x,y is the position of the clip when it is composed with other clips. See VideoClip.set_pos for more details

relative_pos
See variable pos.

layer
Indicates which clip is rendered on top when two clips overlap in a CompositeVideoClip. The highest number is rendered on top. Default is 0.

property aspect_ratio
Returns the aspect ratio of the video.

compose_mask(background_mask: ndarray, t: float) → ndarray[source]
Returns the result of the clip’s mask at time t composited on the given background_mask, the position of the clip being given by the clip’s pos attribute. Meant for compositing.

(warning: only use this function to blit two masks together, never images)

Parameters
:
background_mask – The underlying mask onto which the clip mask will be composed.

t – The time position in the clip at which to extract the mask.

compose_on(background: Image, t) → Image[source]
Returns the result of the clip’s frame at time t on top on the given picture, the position of the clip being given by the clip’s pos attribute. Meant for compositing.

If the clip/backgrounds have transparency the transparency will be accounted for.

The return is a Pillow Image

Parameters
:
(Image) (backrgound) – The background image to apply current clip on top of if the background image is transparent it must be given as a RGBA image

t – The time of clip to apply on top of clip

Return –

copy()
Mixed copy of the clip.

Returns a shallow copy of the clip whose mask and audio will be shallow copies of the clip’s mask and audio if they exist.

This method is intensively used to produce new clips every time there is an outplace transformation of the clip (clip.resize, clip.subclipped, etc.)

Acts like a deepcopy except for the fact that readers and other possible unpickleables objects are not copied.

cropped(x1: int = None, y1: int = None, x2: int = None, y2: int = None, width: int = None, height: int = None, x_center: int = None, y_center: int = None)[source]
Returns a new clip in which just a rectangular subregion of the original clip is conserved. x1,y1 indicates the top left corner and x2,y2 is the lower right corner of the cropped region. All coordinates are in pixels. Float numbers are accepted. For info on the parameters, please see vfx.Crop

display_in_notebook(filetype=None, maxduration=60, t=None, fps=None, rd_kwargs=None, center=True, **html_kwargs)
Displays clip content in an Jupyter Notebook.

Remarks: If your browser doesn’t support HTML5, this should warn you. If nothing is displayed, maybe your file or filename is wrong. Important: The media will be physically embedded in the notebook.

Parameters
:
clip (moviepy.Clip.Clip) – Either the name of a file, or a clip to preview. The clip will actually be written to a file and embedded as if a filename was provided.

filetype (str, optional) – One of "video", "image" or "audio". If None is given, it is determined based on the extension of filename, but this can bug.

maxduration (float, optional) – An error will be raised if the clip’s duration is more than the indicated value (in seconds), to avoid spoiling the browser’s cache and the RAM.

t (float, optional) – If not None, only the frame at time t will be displayed in the notebook, instead of a video of the clip.

fps (int, optional) – Enables to specify an fps, as required for clips whose fps is unknown.

rd_kwargs (dict, optional) – Keyword arguments for the rendering, like dict(fps=15, bitrate="50k"). Allow you to give some options to the render process. You can, for example, disable the logger bar passing dict(logger=None).

center (bool, optional) – If true (default), the content will be wrapped in a <div align=middle> HTML container, so the content will be displayed at the center.

kwargs – Allow you to give some options, like width=260, etc. When editing looping gifs, a good choice is loop=1, autoplay=1.

Examples

from moviepy import *
# later ...
clip.display_in_notebook(width=360)
clip.audio.display_in_notebook()

clip.write_gif("test.gif")
display_in_notebook('test.gif')

clip.save_frame("first_frame.jpeg")
display_in_notebook("first_frame.jpeg")
fill_array(pre_array, shape=(0, 0))[source]
Fills an array to match the specified shape.

If the pre_array is smaller than the desired shape, the missing rows or columns are added with ones to the bottom or right, respectively, until the shape matches. If the pre_array is larger than the desired shape, the excess rows or columns are cropped from the bottom or right, respectively, until the shape matches.

The resulting array with the filled shape is returned.

Parameters
:
(numpy.ndarray) (pre_array) – The original array to be filled.

(tuple) (shape) – The desired shape of the resulting array.

property h
Returns the height of the video.

image_transform(image_func, apply_to=None)[source]
Modifies the images of a clip by replacing the frame get_frame(t) by another frame, image_func(get_frame(t)).

property n_frames
Returns the number of frames of the video.

preview(fps=15, audio=True, audio_fps=22050, audio_buffersize=3000, audio_nbytes=2)[source]
Displays the clip in a window, at the given frames per second.

It will avoid that the clip be played faster than normal, but it cannot avoid the clip to be played slower than normal if the computations are complex. In this case, try reducing the fps.

Parameters
:
fps (int, optional) –

15. (Number of frames per seconds in the displayed video. Default to) –

audio (bool, optional) –

during (True (default) if you want the clip's audio be played) –

preview. (the) –

audio_fps (int, optional) –

sound. (The number of bytes used generating the audio) –

audio_buffersize (int, optional) –

sound. –

audio_nbytes (int, optional) –

sound. –

Examples

from moviepy import *
clip = VideoFileClip("media/chaplin.mp4")
clip.preview(fps=10, audio=False)
resized(new_size=None, height=None, width=None, apply_to_mask=True)[source]
Returns a video clip that is a resized version of the clip. For info on the parameters, please see vfx.Resize

rotated(angle: float, unit: str = 'deg', resample: str = 'bicubic', expand: bool = False, center: tuple = None, translate: tuple = None, bg_color: tuple = None)[source]
Rotates the specified clip by angle degrees (or radians) anticlockwise If the angle is not a multiple of 90 (degrees) or center, translate, and bg_color are not None. For info on the parameters, please see vfx.Rotate

save_frame(filename, t=0, with_mask=True)[source]
Save a clip’s frame to an image file.

Saves the frame of clip corresponding to time t in filename. t can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’.

Parameters
:
filename (str) – Name of the file in which the frame will be stored.

t (float or tuple or str, optional) – Moment of the frame to be saved. As default, the first frame will be saved.

with_mask (bool, optional) – If is True the mask is saved in the alpha layer of the picture (only works with PNGs).

show(t=0, with_mask=True)[source]
Splashes the frame of clip corresponding to time t.

Parameters
:
t (float or tuple or str, optional) –

display. (Time in seconds of the frame to) –

with_mask (bool, optional) –

without (False if the clip has a mask but you want to see the clip) –

mask. (the) –

Examples

from moviepy import *

clip = VideoFileClip("media/chaplin.mp4")
clip.show(t=4)
to_ImageClip(t=0, with_mask=True, duration=None)[source]
Returns an ImageClip made out of the clip’s frame at time t, which can be expressed in seconds (15.35), in (min, sec), in (hour, min, sec), or as a string: ‘01:03:05.35’.

to_RGB()[source]
Return a non-mask video clip made from the mask video clip.

to_mask(canal=0)[source]
Return a mask a video clip made from the clip.

property w
Returns the width of the video.

with_audio(audioclip)[source]
Attach an AudioClip to the VideoClip.

Returns a copy of the VideoClip instance, with the audio attribute set to audio, which must be an AudioClip instance.

with_background_color(size=None, color=(0, 0, 0), pos=None, opacity=None)[source]
Place the clip on a colored background.

Returns a clip made of the current clip overlaid on a color clip of a possibly bigger size. Can serve to flatten transparent clips.

Parameters
:
size – Size (width, height) in pixels of the final clip. By default it will be the size of the current clip.

color – Background color of the final clip ([R,G,B]).

pos – Position of the clip in the final clip. ‘center’ is the default

opacity – Parameter in 0..1 indicating the opacity of the colored background.

with_effects_on_subclip(effects: List[Effect], start_time=0, end_time=None, **kwargs)[source]
Apply a transformation to a part of the clip.

Returns a new clip in which the function fun (clip->clip) has been applied to the subclip between times start_time and end_time (in seconds).

Examples

# The scene between times t=3s and t=6s in ``clip`` will be
# be played twice slower in ``new_clip``
new_clip = clip.with_sub_effect(MultiplySpeed(0.5), 3, 6)
with_layer_index(index)[source]
Set the clip’s layer in compositions. Clips with a greater layer attribute will be displayed on top of others.

Note: Only has effect when the clip is used in a CompositeVideoClip.

with_mask(mask: VideoClip | str = 'auto')[source]
Set the clip’s mask.

Returns a copy of the VideoClip with the mask attribute set to mask, which must be a greyscale (values in 0-1) VideoClip.

Parameters
:
mask (Union["VideoClip", str], optional) – The mask to apply to the clip. If set to “auto”, a default mask will be generated: - If the clip has a constant size, a solid mask with a value of 1.0 will be created. - Otherwise, a dynamic solid mask will be created based on the frame size.

with_opacity(opacity)[source]
Set the opacity/transparency level of the clip.

Returns a semi-transparent copy of the clip where the mask is multiplied by op (any float, normally between 0 and 1).

with_position(pos, relative=False)[source]
Set the clip’s position in compositions.

Sets the position that the clip will have when included in compositions. The argument pos can be either a couple (x,y) or a function t-> (x,y). x and y mark the location of the top left corner of the clip, and can be of several types.

Examples

clip.with_position((45,150)) # x=45, y=150

# clip horizontally centered, at the top of the picture
clip.with_position(("center","top"))

# clip is at 40% of the width, 70% of the height:
clip.with_position((0.4,0.7), relative=True)

# clip's position is horizontally centered, and moving up !
clip.with_position(lambda t: ('center', 50+t))
with_updated_frame_function(frame_function: Callable[[float], ndarray])[source]
Change the clip’s get_frame.

Returns a copy of the VideoClip instance, with the frame_function attribute set to mf.

without_audio()[source]
Remove the clip’s audio.

Return a copy of the clip with audio set to None.

without_mask()[source]
Remove the clip’s mask.

write_gif(filename, fps=None, loop=0, logger='bar')[source]
Write the VideoClip to a GIF file.

Converts a VideoClip into an animated GIF using imageio

Parameters
:
filename – Name of the resulting gif file, as a string or a path-like object.

fps – Number of frames per second (see note below). If it isn’t provided, then the function will look for the clip’s fps attribute (VideoFileClip, for instance, have one).

loop (int, optional) – Repeat the clip using loop iterations in the resulting GIF.

progress_bar – If True, displays a progress bar

Notes

The gif will be playing the clip in real time (you can only change the frame rate). If you want the gif to be played slower than the clip you will use

# slow down clip 50% and make it a gif
myClip.multiply_speed(0.5).to_gif('myClip.gif')
write_images_sequence(name_format, fps=None, with_mask=True, logger='bar')[source]
Writes the videoclip to a sequence of image files.

Parameters
:
name_format – A filename specifying the numerotation format and extension of the pictures. For instance “frame%03d.png” for filenames indexed with 3 digits and PNG format. Also possible: “some_folder/frame%04d.jpeg”, etc.

fps – Number of frames per second to consider when writing the clip. If not specified, the clip’s fps attribute will be used if it has one.

with_mask – will save the clip’s mask (if any) as an alpha canal (PNGs only).

logger – Either "bar" for progress bar or None or any Proglog logger.

Returns
:
A list of all the files generated.

Return type
:
names_list

Notes

The resulting image sequence can be read using e.g. the class ImageSequenceClip.

write_videofile(filename, fps=None, codec=None, bitrate=None, audio=True, audio_fps=44100, preset='medium', audio_nbytes=4, audio_codec=None, audio_bitrate=None, audio_bufsize=2000, temp_audiofile=None, temp_audiofile_path='', remove_temp=True, write_logfile=False, threads=None, ffmpeg_params=None, logger='bar', pixel_format=None)[source]
Write the clip to a videofile.

Parameters
:
filename – Name of the video file to write in, as a string or a path-like object. The extension must correspond to the “codec” used (see below), or simply be ‘.avi’ (which will work with any codec).

fps – Number of frames per second in the resulting video file. If None is provided, and the clip has an fps attribute, this fps will be used.

codec –

Codec to use for image encoding. Can be any codec supported by ffmpeg. If the filename is has extension ‘.mp4’, ‘.ogv’, ‘.webm’, the codec will be set accordingly, but you can still set it if you don’t like the default. For other extensions, the output filename must be set accordingly.

Some examples of codecs are:

'libx264' (default codec for file extension .mp4) makes well-compressed videos (quality tunable using ‘bitrate’).

'mpeg4' (other codec for extension .mp4) can be an alternative to 'libx264', and produces higher quality videos by default.

'rawvideo' (use file extension .avi) will produce a video of perfect quality, of possibly very huge size.

png (use file extension .avi) will produce a video of perfect quality, of smaller size than with rawvideo.

'libvorbis' (use file extension .ogv) is a nice video format, which is completely free/ open source. However not everyone has the codecs installed by default on their machine.

'libvpx' (use file extension .webm) is tiny a video format well indicated for web videos (with HTML5). Open source.

audio – Either True, False, or a file name. If True and the clip has an audio clip attached, this audio clip will be incorporated as a soundtrack in the movie. If audio is the name of an audio file, this audio file will be incorporated as a soundtrack in the movie.

audio_fps – frame rate to use when generating the sound.

temp_audiofile – the name of the temporary audiofile, as a string or path-like object, to be created and then used to write the complete video, if any.

temp_audiofile_path – the location that the temporary audiofile is placed, as a string or path-like object. Defaults to the current working directory.

audio_codec – Which audio codec should be used. Examples are ‘libmp3lame’ for ‘.mp3’, ‘libvorbis’ for ‘ogg’, ‘libfdk_aac’:’m4a’, ‘pcm_s16le’ for 16-bit wav and ‘pcm_s32le’ for 32-bit wav. Default is ‘libmp3lame’, unless the video extension is ‘ogv’ or ‘webm’, at which case the default is ‘libvorbis’.

audio_bitrate – Audio bitrate, given as a string like ‘50k’, ‘500k’, ‘3000k’. Will determine the size/quality of audio in the output file. Note that it mainly an indicative goal, the bitrate won’t necessarily be the this in the final file.

preset – Sets the time that FFMPEG will spend optimizing the compression. Choices are: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo. Note that this does not impact the quality of the video, only the size of the video file. So choose ultrafast when you are in a hurry and file size does not matter.

threads – Number of threads to use for ffmpeg. Can speed up the writing of the video on multicore computers.

ffmpeg_params – Any additional ffmpeg parameters you would like to pass, as a list of terms, like [‘-option1’, ‘value1’, ‘-option2’, ‘value2’].

write_logfile – If true, will write log files for the audio and the video. These will be files ending with ‘.log’ with the name of the output file in them.

logger – Either "bar" for progress bar or None or any Proglog logger.

pixel_format – Pixel format for the output video file.

Examples

from moviepy import VideoFileClip
clip = VideoFileClip("myvideo.mp4").subclipped(100,120)
clip.write_videofile("my_new_video.mp4")
clip.close()

moviepy.video.compositing
All for compositing video clips.

Modules

moviepy.video.compositing.CompositeVideoClip

Main video composition interface of MoviePy.



moviepy.video.compositing.CompositeVideoClip
Main video composition interface of MoviePy.

Classes

CompositeVideoClip(clips[, size, bg_color, ...])

A VideoClip made of other videoclips displayed together.

Functions

clips_array(array[, rows_widths, ...])

Given a matrix whose rows are clips, creates a CompositeVideoClip where all clips are placed side by side horizontally for each clip in each row and one row on top of the other for each row.

concatenate_videoclips(clips[, method, ...])

Concatenates several video clips.

moviepy.video.fx
All the visual effects that can be applied to VideoClip.

Modules

moviepy.video.fx.AccelDecel([new_duration, ...])

Accelerates and decelerates a clip, useful for GIF making.

moviepy.video.fx.BlackAndWhite([RGB, ...])

Desaturates the picture, makes it black and white.

moviepy.video.fx.Blink(duration_on, duration_off)

Makes the clip blink.

moviepy.video.fx.Crop([x1, y1, x2, y2, ...])

Effect to crop a clip to get a new clip in which just a rectangular subregion of the original clip is conserved.

moviepy.video.fx.CrossFadeIn(duration)

Makes the clip appear progressively, over duration seconds.

moviepy.video.fx.CrossFadeOut(duration)

Makes the clip disappear progressively, over duration seconds.

moviepy.video.fx.EvenSize()

Crops the clip to make dimensions even.

moviepy.video.fx.FadeIn(duration[, ...])

Makes the clip progressively appear from some color (black by default), over duration seconds at the beginning of the clip.

moviepy.video.fx.FadeOut(duration[, final_color])

Makes the clip progressively fade to some color (black by default), over duration seconds at the end of the clip.

moviepy.video.fx.Freeze([t, ...])

Momentarily freeze the clip at time t.

moviepy.video.fx.FreezeRegion([t, region, ...])

Freezes one region of the clip while the rest remains animated.

moviepy.video.fx.GammaCorrection(gamma)

Gamma-correction of a video clip.

moviepy.video.fx.HeadBlur(fx, fy, radius[, ...])

Returns a filter that will blur a moving part (a head ?) of the frames.

moviepy.video.fx.InvertColors()

Returns the color-inversed clip.

moviepy.video.fx.Loop([n, duration])

Returns a clip that plays the current clip in an infinite loop.

moviepy.video.fx.LumContrast([lum, ...])

Luminosity-contrast correction of a clip.

moviepy.video.fx.MakeLoopable(overlap_duration)

Makes the clip fade in progressively at its own end, this way it can be looped indefinitely.

moviepy.video.fx.Margin([margin_size, left, ...])

Draws an external margin all around the frame.

moviepy.video.fx.MaskColor([color, ...])

Returns a new clip with a mask for transparency where the original clip is of the given color.

moviepy.video.fx.MasksAnd(other_clip)

Returns the logical 'and' (minimum pixel color values) between two masks.

moviepy.video.fx.MasksOr(other_clip)

Returns the logical 'or' (maximum pixel color values) between two masks.

moviepy.video.fx.MirrorX([apply_to])

Flips the clip horizontally (and its mask too, by default).

moviepy.video.fx.MirrorY([apply_to])

Flips the clip vertically (and its mask too, by default).

moviepy.video.fx.MultiplyColor(factor)

Multiplies the clip's colors by the given factor, can be used to decrease or increase the clip's brightness (is that the right word ?)

moviepy.video.fx.MultiplySpeed([factor, ...])

Returns a clip playing the current clip but at a speed multiplied by factor.

moviepy.video.fx.Painting([saturation, black])

Transforms any photo into some kind of painting.

moviepy.video.fx.Resize([new_size, height, ...])

Effect returning a video clip that is a resized version of the clip.

moviepy.video.fx.Rotate(angle[, unit, ...])

Rotates the specified clip by angle degrees (or radians) anticlockwise If the angle is not a multiple of 90 (degrees) or center, translate, and bg_color are not None, there will be black borders.

moviepy.video.fx.Scroll([w, h, x_speed, ...])

Effect that scrolls horizontally or vertically a clip, e.g.

moviepy.video.fx.SlideIn(duration, side)

Makes the clip arrive from one side of the screen.

moviepy.video.fx.SlideOut(duration, side)

Makes the clip goes away by one side of the screen.

moviepy.video.fx.SuperSample(d, n_frames)

Replaces each frame at time t by the mean of n_frames equally spaced frames taken in the interval [t-d, t+d].

moviepy.video.fx.TimeMirror()

Returns a clip that plays the current clip backwards.

moviepy.video.fx.TimeSymmetrize()

Returns a clip that plays the current clip once forwards and then once backwards.

moviepy.video.fx.AccelDecel
class moviepy.video.fx.AccelDecel.AccelDecel(new_duration: float = None, abruptness: float = 1.0, soonness: float = 1.0)[source]
Accelerates and decelerates a clip, useful for GIF making.

Parameters
:
new_duration (float) – Duration for the new transformed clip. If None, will be that of the current clip.

abruptness (float) –

Slope shape in the acceleration-deceleration function. It will depend on the value of the parameter:

-1 < abruptness < 0: speed up, down, up.

abruptness == 0: no effect.

abruptness > 0: speed down, up, down.

soonness (float) – For positive abruptness, determines how soon the transformation occurs. Should be a positive number.

Raises
:
ValueError – When sooness argument is lower than 0.

Examples

The following graphs show functions generated by different combinations of arguments, where the value of the slopes represents the speed of the videos generated, being the linear function (in red) a combination that does not produce any transformation.

acced_decel FX parameters combinations
apply(clip)[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.BlackAndWhite
class moviepy.video.fx.BlackAndWhite.BlackAndWhite(RGB: str = None, preserve_luminosity: bool = True)[source]
Desaturates the picture, makes it black and white. Parameter RGB allows to set weights for the different color channels. If RBG is ‘CRT_phosphor’ a special set of values is used. preserve_luminosity maintains the sum of RGB to 1.

apply(clip)[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.Blink
class moviepy.video.fx.Blink.Blink(duration_on: float, duration_off: float)[source]
Makes the clip blink. At each blink it will be displayed duration_on seconds and disappear duration_off seconds. Will only work in composite clips.

apply(clip)[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.Crop
class moviepy.video.fx.Crop.Crop(x1: int = None, y1: int = None, x2: int = None, y2: int = None, width: int = None, height: int = None, x_center: int = None, y_center: int = None)[source]
Effect to crop a clip to get a new clip in which just a rectangular subregion of the original clip is conserved. x1,y1 indicates the top left corner and x2,y2 is the lower right corner of the cropped region. All coordinates are in pixels. Float numbers are accepted.

To crop an arbitrary rectangle:

Crop(x1=50, y1=60, x2=460, y2=275)
Only remove the part above y=30:

Crop(y1=30)
Crop a rectangle that starts 10 pixels left and is 200px wide

Crop(x1=10, width=200)
Crop a rectangle centered in x,y=(300,400), width=50, height=150 :

Crop(x_center=300, y_center=400, width=50, height=150)
Any combination of the above should work, like for this rectangle centered in x=300, with explicit y-boundaries:

Crop(x_center=300, width=400, y1=100, y2=600)
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.CrossFadeIn
class moviepy.video.fx.CrossFadeIn.CrossFadeIn(duration: float)[source]
Makes the clip appear progressively, over duration seconds. Only works when the clip is included in a CompositeVideoClip.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.CrossFadeOut
class moviepy.video.fx.CrossFadeOut.CrossFadeOut(duration: float)[source]
Makes the clip disappear progressively, over duration seconds. Only works when the clip is included in a CompositeVideoClip.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.EvenSize
class moviepy.video.fx.EvenSize.EvenSize[source]
Crops the clip to make dimensions even.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.FadeIn
class moviepy.video.fx.FadeIn.FadeIn(duration: float, initial_color: list = None)[source]
Makes the clip progressively appear from some color (black by default), over duration seconds at the beginning of the clip. Can be used for masks too, where the initial color must be a number between 0 and 1.

For cross-fading (progressive appearance or disappearance of a clip over another clip, see CrossFadeIn

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.FadeOut
class moviepy.video.fx.FadeOut.FadeOut(duration: float, final_color: list = None)[source]
Makes the clip progressively fade to some color (black by default), over duration seconds at the end of the clip. Can be used for masks too, where the final color must be a number between 0 and 1.

For cross-fading (progressive appearance or disappearance of a clip over another clip), see CrossFadeOut

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

previous

moviepy.video.fx.FadeIn



moviepy.video.fx.Freeze
class moviepy.video.fx.Freeze.Freeze(t: float = 0, freeze_duration: float = None, total_duration: float = None, padding_end: float = 0, update_start_end: bool = True)[source]
Momentarily freeze the clip at time t.

Set t=’end’ to freeze the clip at the end (actually it will freeze on the frame at time clip.duration - padding_end seconds - 1 / clip_fps). With duration you can specify the duration of the freeze. With total_duration you can specify the total duration of the clip and the freeze (i.e. the duration of the freeze is automatically computed). One of them must be provided.

With update_start_end you can define if the effect must preserve and/or update start and end properties of the original clip

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.FreezeRegion
class moviepy.video.fx.FreezeRegion.FreezeRegion(t: float = 0, region: tuple = None, outside_region: tuple = None, mask: Clip = None)[source]
Freezes one region of the clip while the rest remains animated.

You can choose one of three methods by providing either region, outside_region, or mask.

Parameters
:
t (float) – Time at which to freeze the freezed region.

region (tuple) – A tuple (x1, y1, x2, y2) defining the region of the screen (in pixels) which will be freezed. You can provide outside_region or mask instead.

outside_region (tuple) – A tuple (x1, y1, x2, y2) defining the region of the screen (in pixels) which will be the only non-freezed region.

mask (moviepy.Clip.Clip) – If not None, will overlay a freezed version of the clip on the current clip, with the provided mask. In other words, the “visible” pixels in the mask indicate the freezed region in the final picture.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.GammaCorrection
class moviepy.video.fx.GammaCorrection.GammaCorrection(gamma: float)[source]
Gamma-correction of a video clip.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.HeadBlur
class moviepy.video.fx.HeadBlur.HeadBlur(fx: callable, fy: callable, radius: float, intensity: float = None)[source]
Returns a filter that will blur a moving part (a head ?) of the frames.

The position of the blur at time t is defined by (fx(t), fy(t)), the radius of the blurring by radius and the intensity of the blurring by intensity.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.InvertColors
class moviepy.video.fx.InvertColors.InvertColors[source]
Returns the color-inversed clip.

The values of all pixels are replaced with (255-v) or (1-v) for masks Black becomes white, green becomes purple, etc.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.Loop
class moviepy.video.fx.Loop.Loop(n: int = None, duration: float = None)[source]
Returns a clip that plays the current clip in an infinite loop. Ideal for clips coming from GIFs.

Parameters
:
n (int) – Number of times the clip should be played. If None the the clip will loop indefinitely (i.e. with no set duration).

duration (float) – Total duration of the clip. Can be specified instead of n.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.LumContrast
class moviepy.video.fx.LumContrast.LumContrast(lum: float = 0, contrast: float = 0, contrast_threshold: float = 127)[source]
Luminosity-contrast correction of a clip.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MakeLoopable
class moviepy.video.fx.MakeLoopable.MakeLoopable(overlap_duration: float)[source]
Makes the clip fade in progressively at its own end, this way it can be looped indefinitely.

Parameters
:
overlap_duration (float) – Duration of the fade-in (in seconds).

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.Margin
class moviepy.video.fx.Margin.Margin(margin_size: int = None, left: int = 0, right: int = 0, top: int = 0, bottom: int = 0, color: tuple = (0, 0, 0), opacity: float = 1.0)[source]
Draws an external margin all around the frame.

Parameters
:
margin_size (int, optional) – If not None, then the new clip has a margin size of size margin_size in pixels on the left, right, top, and bottom.

left (int, optional) – If margin_size=None, margin size for the new clip in left direction.

right (int, optional) – If margin_size=None, margin size for the new clip in right direction.

top (int, optional) – If margin_size=None, margin size for the new clip in top direction.

bottom (int, optional) – If margin_size=None, margin size for the new clip in bottom direction.

color (tuple, optional) – Color of the margin.

opacity (float, optional) – Opacity of the margin. Setting this value to 0 yields transparent margins.

add_margin(clip: Clip)[source]
Add margins to the clip.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MaskColor
class moviepy.video.fx.MaskColor.MaskColor(color: tuple = (0, 0, 0), threshold: float = 0, stiffness: float = 1)[source]
Returns a new clip with a mask for transparency where the original clip is of the given color.

You can also have a “progressive” mask by specifying a non-null distance threshold threshold. In this case, if the distance between a pixel and the given color is d, the transparency will be

d**stiffness / (threshold**stiffness + d**stiffness)

which is 1 when d>>threshold and 0 for d<<threshold, the stiffness of the effect being parametrized by stiffness

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MasksAnd
class moviepy.video.fx.MasksAnd.MasksAnd(other_clip: Clip | ndarray)[source]
Returns the logical ‘and’ (minimum pixel color values) between two masks.

The result has the duration of the clip to which has been applied, if it has any.

Parameters
:
np.ndarray (other_clip ImageClip or) – Clip used to mask the original clip.

Examples

clip = ColorClip(color=(255, 0, 0), size=(1, 1))      # red
mask = ColorClip(color=(0, 255, 0), size=(1, 1))      # green
masked_clip = clip.with_effects([vfx.MasksAnd(mask)]) # black
masked_clip.get_frame(0)
[[[0 0 0]]]
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MasksOr
class moviepy.video.fx.MasksOr.MasksOr(other_clip: Clip | ndarray)[source]
Returns the logical ‘or’ (maximum pixel color values) between two masks.

The result has the duration of the clip to which has been applied, if it has any.

Parameters
:
np.ndarray (other_clip ImageClip or) – Clip used to mask the original clip.

Examples

clip = ColorClip(color=(255, 0, 0), size=(1, 1))     # red
mask = ColorClip(color=(0, 255, 0), size=(1, 1))     # green
masked_clip = clip.with_effects([vfx.MasksOr(mask)]) # yellow
masked_clip.get_frame(0)
[[[255 255   0]]]
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MirrorX
class moviepy.video.fx.MirrorX.MirrorX(apply_to: List | str = 'mask')[source]
Flips the clip horizontally (and its mask too, by default).

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MirrorY
class moviepy.video.fx.MirrorY.MirrorY(apply_to: List | str = 'mask')[source]
Flips the clip vertically (and its mask too, by default).

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MultiplyColor
class moviepy.video.fx.MultiplyColor.MultiplyColor(factor: float)[source]
Multiplies the clip’s colors by the given factor, can be used to decrease or increase the clip’s brightness (is that the right word ?)

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.MultiplySpeed
class moviepy.video.fx.MultiplySpeed.MultiplySpeed(factor: float = None, final_duration: float = None)[source]
Returns a clip playing the current clip but at a speed multiplied by factor.

Instead of factor one can indicate the desired final_duration of the clip, and the factor will be automatically computed. The same effect is applied to the clip’s audio and mask if any.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.Painting
class moviepy.video.fx.Painting.Painting(saturation: float = 1.4, black: float = 0.006)[source]
Transforms any photo into some kind of painting.

Transforms any photo into some kind of painting. Saturation tells at which point the colors of the result should be flashy. black gives the amount of black lines wanted.

np_image : a numpy image

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

to_painting(np_image, saturation=1.4, black=0.006)[source]
Transforms any photo into some kind of painting.

Transforms any photo into some kind of painting. Saturation tells at which point the colors of the result should be flashy. black gives the amount of black lines wanted.

np_image : a numpy image

moviepy.video.fx.Resize
class moviepy.video.fx.Resize.Resize(new_size: tuple | float | callable = None, height: int = None, width: int = None, apply_to_mask: bool = True)[source]
Effect returning a video clip that is a resized version of the clip.

Parameters
:
new_size (tuple or float or function, optional) – Can be either - (width, height) in pixels or a float representing - A scaling factor, like 0.5. - A function of time returning one of these.

height (int, optional) – Height of the new clip in pixels. The width is then computed so that the width/height ratio is conserved.

width (int, optional) – Width of the new clip in pixels. The height is then computed so that the width/height ratio is conserved.

Examples

clip.with_effects([vfx.Resize((460,720))]) # New resolution: (460,720)
clip.with_effects([vfx.Resize(0.6)]) # width and height multiplied by 0.6
clip.with_effects([vfx.Resize(width=800)]) # height computed automatically.
clip.with_effects([vfx.Resize(lambda t : 1+0.02*t)]) # slow clip swelling
apply(clip)[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

resizer(pic, new_size)[source]
Resize the image using PIL.

moviepy.video.fx.Rotate
class moviepy.video.fx.Rotate.Rotate(angle: float, unit: str = 'deg', resample: str = 'bicubic', expand: bool = True, center: tuple = None, translate: tuple = None, bg_color: tuple = None)[source]
Rotates the specified clip by angle degrees (or radians) anticlockwise If the angle is not a multiple of 90 (degrees) or center, translate, and bg_color are not None, there will be black borders. You can make them transparent with:

new_clip = clip.with_mask().rotate(72)
Parameters
:
clip (VideoClip) –

clip. (A video) –

angle (float) –

rotation. (Either a value or a function angle(t) representing the angle of) –

unit (str, optional) –

radians). (Unit of parameter angle (either "deg" for degrees or "rad" for) –

resample (str, optional) –

"nearest" (An optional resampling filter. One of) –

"bilinear" –

"bicubic". (or) –

expand (bool, optional) –

true (If) –

the (expands the output image to make it large enough to hold) –

omitted (entire rotated image. If false or) –

same (make the output image the) –

image. (size as the input) –

translate (tuple, optional) –

2-tuple). (An optional post-rotate translation (a) –

center (tuple, optional) –

corner. (Optional center of rotation (a 2-tuple). Origin is the upper left) –

bg_color (tuple, optional) –

if (An optional color for area outside the rotated image. Only has effect) –

true. (expand is) –

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.	
moviepy.video.fx.Scroll
class moviepy.video.fx.Scroll.Scroll(w=None, h=None, x_speed=0, y_speed=0, x_start=0, y_start=0, apply_to='mask')[source]
Effect that scrolls horizontally or vertically a clip, e.g. to make end credits

Parameters
:
w – The width and height of the final clip. Default to clip.w and clip.h

h – The width and height of the final clip. Default to clip.w and clip.h

x_speed – The speed of the scroll in the x and y directions.

y_speed – The speed of the scroll in the x and y directions.

x_start – The starting position of the scroll in the x and y directions.

y_start – The starting position of the scroll in the x and y directions.

apply_to
Whether to apply the effect to the mask too.

apply(clip)[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

previous

moviepy.video.fx.Rotate



moviepy.video.fx.SlideIn
class moviepy.video.fx.SlideIn.SlideIn(duration: float, side: str)[source]
Makes the clip arrive from one side of the screen.

Only works when the clip is included in a CompositeVideoClip, and if the clip has the same size as the whole composition.

Parameters
:
clip (moviepy.Clip.Clip) – A video clip.

duration (float) – Time taken for the clip to be fully visible

side (str) – Side of the screen where the clip comes from. One of ‘top’, ‘bottom’, ‘left’ or ‘right’.

Examples

from moviepy import *

clips = [... make a list of clips]
slided_clips = [
    CompositeVideoClip([clip.with_effects([vfx.SlideIn(1, "left")])])
    for clip in clips
]
final_clip = concatenate_videoclips(slided_clips, padding=-1)

clip = ColorClip(
    color=(255, 0, 0), duration=1, size=(300, 300)
).with_fps(60)
final_clip = CompositeVideoClip([clip.with_effects([vfx.SlideIn(1, "right")])])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.SlideOut
class moviepy.video.fx.SlideOut.SlideOut(duration: float, side: str)[source]
Makes the clip goes away by one side of the screen.

Only works when the clip is included in a CompositeVideoClip, and if the clip has the same size as the whole composition.

Parameters
:
clip (moviepy.Clip.Clip) – A video clip.

duration (float) – Time taken for the clip to be fully visible

side (str) – Side of the screen where the clip goes. One of ‘top’, ‘bottom’, ‘left’ or ‘right’.

Examples

from moviepy import *

clips = [... make a list of clips]
slided_clips = [
    CompositeVideoClip([clip.with_effects([vfx.SlideOut(1, "left")])])
    for clip in clips
]
final_clip = concatenate_videoclips(slided_clips, padding=-1)

clip = ColorClip(
    color=(255, 0, 0), duration=1, size=(300, 300)
).with_fps(60)
final_clip = CompositeVideoClip([clip.with_effects([vfx.SlideOut(1, "right")])])
apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.SuperSample
class moviepy.video.fx.SuperSample.SuperSample(d: float, n_frames: int)[source]
Replaces each frame at time t by the mean of n_frames equally spaced frames taken in the interval [t-d, t+d]. This results in motion blur.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.TimeMirror
class moviepy.video.fx.TimeMirror.TimeMirror[source]
Returns a clip that plays the current clip backwards. The clip must have its duration attribute set. The same effect is applied to the clip’s audio and mask if any.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.fx.TimeSymmetrize
class moviepy.video.fx.TimeSymmetrize.TimeSymmetrize[source]
Returns a clip that plays the current clip once forwards and then once backwards. This is very practival to make video that loop well, e.g. to create animated GIFs. This effect is automatically applied to the clip’s mask and audio if they exist.

apply(clip: Clip) → Clip[source]
Apply the effect to the clip.

copy()
Return a shallow copy of an Effect.

You must always copy an Effect before applying, because some of them will modify their own attributes when applied. For example, setting a previously unset property by using target clip property.

If we was to use the original effect, calling the same effect multiple times could lead to different properties, and different results for equivalent clips.

By using copy, we ensure we can use the same effect object multiple times while maintaining the same behavior/result.

In a way, copy makes the effect himself being kind of idempotent.

moviepy.video.io
Classes and methods for reading, writing and previewing video files.

Modules

moviepy.video.io.ImageSequenceClip

Implements ImageSequenceClip, a class to create a video clip from a set of image files.

moviepy.video.io.VideoFileClip

Implements VideoFileClip, a class for video clips creation using video files.

moviepy.video.io.display_in_notebook

Implements display_in_notebook, a function to embed images/videos/audio in the Jupyter Notebook.

moviepy.video.io.ffmpeg_reader

Implements all the functions to read a video or a picture using ffmpeg.

moviepy.video.io.ffmpeg_tools

Miscellaneous bindings to ffmpeg.

moviepy.video.io.ffmpeg_writer

On the long term this will implement several methods to make videos out of VideoClips

moviepy.video.io.ffplay_previewer

On the long term this will implement several methods to make videos out of VideoClips

moviepy.video.io.gif_writers

MoviePy video GIFs writing.



moviepy.video.io.ImageSequenceClip
Implements ImageSequenceClip, a class to create a video clip from a set of image files.

Classes

ImageSequenceClip(sequence[, fps, ...])

A VideoClip made from a series of images.

moviepy.video.io.VideoFileClip
Implements VideoFileClip, a class for video clips creation using video files.

Classes

VideoFileClip(filename[, decode_file, ...])

A video clip originating from a movie file.



moviepy.video.io.display_in_notebook
Implements display_in_notebook, a function to embed images/videos/audio in the Jupyter Notebook.

Functions

HTML2(content)

display_in_notebook(clip[, filetype, ...])

Displays clip content in an Jupyter Notebook.

html_embed(clip[, filetype, maxduration, ...])

Returns HTML5 code embedding the clip.

previous

moviepy.video.io.VideoFileClip.VideoFileClip

next

moviepy.video.io.display_in_notebook.HTML2

 Edit on GitHub
 Show Source

moviepy.video.io.ffmpeg_reader
Implements all the functions to read a video or a picture using ffmpeg.

Classes

FFMPEG_VideoReader(filename[, decode_file, ...])

Class for video byte-level reading with ffmpeg.

FFmpegInfosParser(infos, filename[, ...])

Finite state ffmpeg -i command option file information parser.

Functions

ffmpeg_parse_infos(filename[, ...])

Get the information of a file using ffmpeg.

ffmpeg_read_image(filename[, with_mask, ...])

Read an image file (PNG, BMP, JPEG...).

moviepy.video.io.ffmpeg_tools
Miscellaneous bindings to ffmpeg.

Functions

ffmpeg_extract_audio(inputfile, outputfile)

Extract the sound from a video file and save it in outputfile.

ffmpeg_extract_subclip(inputfile, ...[, ...])

Makes a new video file playing video file between two times.

ffmpeg_merge_video_audio(videofile, ...[, ...])

Merges video file and audio file into one movie file.

ffmpeg_resize(inputfile, outputfile, size[, ...])

Resizes a file to new size and write the result in another.

ffmpeg_stabilize_video(inputfile[, ...])

Stabilizes filename and write the result to output.

ffmpeg_version()

Retrieve the FFmpeg version.

ffplay_version()

Retrieve the FFplay version.

moviepy.video.io.ffmpeg_writer
On the long term this will implement several methods to make videos out of VideoClips

Classes

FFMPEG_VideoWriter(filename, size, fps[, ...])

A class for FFMPEG-based video writing.

Functions

ffmpeg_write_image(filename, image[, ...])

Writes an image (HxWx3 or HxWx4 numpy array) to a file, using ffmpeg.

ffmpeg_write_video(clip, filename, fps[, ...])

Write the clip to a videofile.

moviepy.video.io.ffplay_previewer
On the long term this will implement several methods to make videos out of VideoClips

Classes

FFPLAY_VideoPreviewer(size, fps, pixel_format)

A class for FFPLAY-based video preview.

Functions

ffplay_preview_video(clip, fps[, ...])

moviepy.video.io.gif_writers
MoviePy video GIFs writing.

Functions

write_gif_with_imageio(clip, filename[, ...])

Writes the gif with the Python library ImageIO (calls FreeImage).

moviepy.video.tools
Modules

moviepy.video.tools.credits

Contains different functions to make end and opening credits, even though it is difficult to fill everyone needs in this matter.

moviepy.video.tools.cuts

Contains everything that can help automate the cuts in MoviePy.

moviepy.video.tools.drawing

Deals with making images (np arrays).

moviepy.video.tools.interpolators

Classes for easy interpolation of trajectories and curves.

moviepy.video.tools.subtitles

Experimental module for subtitles support.

moviepy.video.tools.credits
Contains different functions to make end and opening credits, even though it is difficult to fill everyone needs in this matter.

Classes

CreditsClip(creditfile, width[, color, ...])

moviepy.video.tools.cuts
Contains everything that can help automate the cuts in MoviePy.

Classes

FramesMatch(start_time, end_time, ...)

Frames match inside a set of frames.

FramesMatches(lst)

Frames matches inside a set of frames.

Functions

detect_scenes([clip, luminosities, ...])

Detects scenes of a clip based on luminosity changes.

find_video_period(clip[, fps, start_time])

Find the period of a video based on frames correlation.

previous

moviepy.video.tools.credits.CreditsClip

next

moviepy.video.tools.cuts.FramesMatch

 Edit on GitHub


moviepy.video.tools.drawing
Deals with making images (np arrays). It provides drawing methods that are difficult to do with the existing Python libraries.

Functions

circle(screensize, center, radius[, color, ...])

Draw an image with a circle.

color_gradient(size, p1[, p2, vector, ...])

Draw a linear, bilinear, or radial gradient.

color_split(size[, x, y, p1, p2, vector, ...])

Make an image split in 2 colored regions.

moviepy.video.tools.interpolators
Classes for easy interpolation of trajectories and curves.

Classes

Interpolator([tt, ss, ttss, left, right])

Poorman's linear interpolator.

Trajectory(tt, xx, yy)

Trajectory compound by time frames and (x, y) pixels.

moviepy.video.tools.subtitles
Experimental module for subtitles support.

Classes

SubtitlesClip(subtitles[, font, ...])

A Clip that serves as "subtitle track" in videos.

Functions

file_to_subtitles(filename[, encoding])

Converts a srt file into subtitles.